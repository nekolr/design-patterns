# 示例代码类图
示例代码中提供了几种不同的工厂方法模式，包括单一工厂的工厂方法模式，符合单一职责的多工厂的工厂方法模式，简单工厂方法模式。

如果一个模块仅需要一个工厂类，那么提供工厂方法的抽象类或接口就没有必要存在，直接通过一个工厂类的静态方法产生对象即可，这就是简单工厂模式（也叫做静态工厂模式）。单一工厂的工厂方法模式适合那些初始化对象的过程比较简单且一致的情况。如果项目比较复杂，并且初始化一个对象的过程比较繁琐，那么将所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。比如一个产品类有五个具体实现，每个实现的初始化过程（包括 new 对象以及一些对象的设置）都不相同且复杂，那么将它们都写在一个工厂方法中，该方法势必庞大且复杂，此时为每个产品都定义一个工厂类就比较合适，这就是多工厂的工厂方法模式。

***

![单一工厂方法模式](https://github.com/nekolr/design-patterns/blob/master/media/single_factorymethod_example.png)

***

![多工厂的工厂方法模式](https://github.com/nekolr/design-patterns/blob/master/media/multi_factorymethod_example.png)

***

![简单工厂方法模式](https://github.com/nekolr/design-patterns/blob/master/media/simple_factorymethod_example.png)

# 工厂方法模式
![工厂方法模式](https://github.com/nekolr/design-patterns/blob/master/media/factorymethod.png)

定义：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。

- Product 是一个接口或抽象类，负责定义产品的共性，实现对事物最抽象的定义。
- ConcreteProduct 是 Product 具体的实现类。
- Factory 是一个接口或抽象类，定义创建 Product 的方法。
- ConcreteFactory 是 Factory 的具体实现类，具体如何创建 Product 由它来实现。

# 优缺点
优点：

- 可以避免创建对象和使用对象之间的耦合，对象的使用者可以不必了解对象初始化过程的复杂和艰辛，只需要知道这个产品的类名（或者约束字符串）即可。
- 扩展性较强，如果需要增加新产品，只需要有限地修改客户端代码（适当地修改具体的工厂类）甚至不需要修改客户端代码（创建一个新的工厂类既可）即可引入新的产品。符合**开闭原则**。

缺点：

- 使用工厂方法模式可能需要引入许多新的子类，代码因此可能变得复杂。

# 使用场景
- 作为 new 对象的替代，在所有需要生成对象的地方都可以使用，但是要慎重考虑是否需要引入工厂类来管理对象，因为这也会增加代码的复杂度。
- 在需要一个灵活的、可扩展的框架时，可以考虑使用工厂方法模式。
- 如果希望复用现有对象来节省系统资源，而不是每次都重新创建对象，可以使用工厂方法模式结合延迟初始化来完成。

# 典型案例
- 使用 JDBC 连接数据库时，数据库切换只需要修改驱动名称和连接即可。