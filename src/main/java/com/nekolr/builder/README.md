# 示例代码类图
提供了几种不同的实现。汽车的例子中，不同的产品都属于同一个类，所以我们在 Builder 中直接提供了 build 方法。同时这个例子中，组建对象的步骤顺序对结果没有影响。Pizza 的例子中，组建对象的步骤顺序对生产对象有影响。还有一个版本提供了简化后的建造者模式，组建对象的每个步骤都会返回建造者本身，这样我们可以在使用时链式调用。

# 建造者模式
![建造者模式](https://github.com/nekolr/design-patterns/blob/master/media/abstractfactory.png)

定义：将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表示。

建造者模式关注的是零件类型和装配工艺（顺序），当然有的时候可能对顺序没有要求。

- Product 是产品，它有可能是实现了模板方法（比如例子中的 Pizza 类），这种产品一般都会受到生产顺序的影响。
- Builder 是抽象建造者，规范产品的组建，定义了所有可能的生产步骤。
- ConcreteBuilder 是具体的建造者，它实现了抽象类定义的所有方法，同时提供一个方法返回一个组建好的对象。
- Director 是导演类，负责安排已有对象属性的设置或者组建步骤的顺序，然后告诉 Builder 开始建造。

# 优缺点
优点：

- 良好的封装性。客户端不必了解产品内部组成的细节。
- 建造者独立，容易扩展。

缺点：

- 代码复杂度较高

# 使用场景
- 相同的方法，不同的执行顺序，产生不同的结果时，可以采用建造者模式（关注步骤顺序）。
- 当我们希望使用几乎相同的代码创建不同形式的对象时，可以使用建造者模式（关注零件类型）。
- 避免“重叠构造函数”的出现。假如构造函数中有数十个**可选参数**，那么调用它就会很麻烦，一种简单的解决方式就是重载这个构造函数，新建几个只有较少参数的简化版，这些构造函数仍需调用主构造函数，但是可以通过传递一些默认数值来替代省略掉的参数。而建造者模式可以让我们分步骤生成对象，我们只需要调用必须的步骤来生成对象即可。
- 使用建造者模式来构造组合树或其他复杂对象。建造者模式可以让我们分步骤构造产品，我们可以延迟执行某些步骤而不会影响最终产品，我们甚至可以递归调用这些步骤，这在创建对象树时非常方便。

# 注意事项
为每个形式的产品创建具体的建造者时，一定要注意不要忘记提供获取构造结果对象的方法。我们不能在抽象建造者（接口或抽象类）中声明该方法，因为不同的建造者构造的产品可能没有公共的接口（指的是产品可能没有实现一个统一的接口），因此我们就不知道该方法返回的对象类型。**但是，如果所有的产品都位于同一类层次中（实现一个统一的接口或者单纯就是同一个类的对象，只是对象的属性不同），我们就可以安全地在基本接口（抽象建造者）中添加获取生成对象的方法**。

# 典型案例
- JDK 中的 StringBuilder 和 StringBuffer，它们都可以连续使用 append 方法添加数据，只有最终调用 toString 方法后才会构造结果对象。