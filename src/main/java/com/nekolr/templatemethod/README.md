# 示例代码类图
示例代码中的数据抽取分析器将数据抽取、分析和生成报告这一过程分解为一系列步骤，然后将这些步骤改为一个个的方法，最后在模板方法中依次调用这些方法。步骤可以是抽象的，交给子类去实现，也可以是默认的实现。

# 模板方法模式
![模板方法模式](https://github.com/nekolr/design-patterns/blob/master/media/templatemethod.png)

定义：定义一个操作中算法的框架，将算法中的一些步骤延迟到子类中，使得子类可以在不改变算法结构的情况下即可重新定义该算法的某些特定步骤。

- AbstractClass 是抽象模板，它的方法分为两类，其中一类是基本方法，由子类负责实现，并在模板方法中调用。另一类就是模板方法，可以有一个或几个，一般是一个具体的方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。
- ConcreteClass 是抽象模板的具体实现。

# 优缺点
优点：

- 封装不变部分，扩展可变部分。不变的部分由父类封装并实现，可变的部分通过继承来继续扩展，
- 提取公共部分，便于维护。

缺点：

- 按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响到了父类，也就是子类对父类产生了影响，这在复杂项目中会增加代码阅读的难度。
- 模板方法中的方法越多，其维护工作就越困难。
- 使用子类抑制默认的步骤实现可能会导致违反**里氏替换原则**。

# 使用场景
- 多个子类有共有的方法，并且逻辑基本相同。
- 重要且复杂的算法，可以将核心算法设计为模板方法，周边的细节功能由各个子类实现。

# 模板方法模式的扩展
有时可能需要模板方法中的某些步骤根据条件选择是否执行，即外界条件的改变影响到了模板方法中步骤的执行，此时就需要提供钩子方法，有了钩子方法的模板方法才会更加灵活。
