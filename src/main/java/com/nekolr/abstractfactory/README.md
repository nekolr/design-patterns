# 示例代码类图
示例代码中，按钮和单选框是一组相关的产品，抽象工厂定义一组创建它们的抽象方法，具体的抽象工厂根据平台的不同有不同的实现类，相同工厂生产出来的产品应该是同一类型的。

![例子类图](https://github.com/nekolr/design-patterns/blob/master/media/abstractfactory_example.png)

# 抽象工厂模式
![抽象工厂模式](https://github.com/nekolr/design-patterns/blob/master/media/abstractfactory.png)

定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体实现类。

抽象工厂模式是工厂方法模式的升级版，抽象工厂中一般都会有多个相关或者互相影响的产品线（也叫做产品族），比如按钮和单选框，它们就是一组相关的产品。再比如制造汽车的左侧门和右侧门，它们是相关且互相影响的，因为它们必须成对出现。

- 其中 ProductA 和 ProductB 都是产品接口或抽象类，有的类图可能会使用一个 AbstractProduct 来表示产品接口或抽象类。
- ConcreteProduct 是产品的具体实现类。
- AbstractFactory 是抽象工厂的接口或抽象类，它提供创建一系列产品的方法。
- ConcreteFactory 是具体的工厂类，同一个工厂生产出来的产品一般都属于同一类（同一产品族）。

# 优缺点
优点：

- 良好的封装性。客户端不必了解产品是如何创建出来的，只需要知道哪个工厂可以提供需要的产品即可，从而避免客户端与具体的产品代码耦合。
- 产品族内的约束（比如汽车左侧门和右侧门必须成对地创建出来）对客户端来说是透明的，即客户端调用工厂即可，工厂自己会按照约束生产。

缺点：

- 产品族扩展困难。比如我们要新增加一个产品，那么不光需要修改抽象工厂的代码，还需要对应的修改每一个抽象工厂的具体实现的代码。

# 使用场景
- 当一个对象族（或是一组没有任何关系的对象）都具有相同的约束时，就可以使用抽象工厂模式。比如文本编辑器和图片编辑器都是软件实体，一个文本编辑器在 Windows 系统中和在 Linux 系统中的功能和界面虽然相同，但是实现的代码不同，图片编辑器也是如此。这时的约束条件就是：操作系统，即同一个工厂生产出来的产品应该属于同一个操作系统。

# 注意事项
虽然抽象工厂的产品族扩展困难，但这不代表产品等级扩展困难。比如按钮和单选框组件，一开始我们提供了 Windows 平台和 macOS 平台的工厂，后来出现了一个新的平台，我们只需要添加一个新平台的工厂即可，客户端只需要修改少量代码甚至不需要修改代码。
